package main

// Don't edit this file. 

var tmpl = `// Code generated by bindgen, DO NOT EDIT.

package {{.package}}

import "github.com/newalchemylimited/seth"

{{range $c := .contracts}}

	type {{$c.Name}} struct {
		addr  *seth.Address
		s     seth.Sender
	}

	func New{{$c.Name}}(addr *seth.Address, sender seth.Sender) *{{$c.Name}} {
		return &{{$c.Name}}{addr: addr, s: sender}
	}

	{{range $d := $c.ABI}}

		{{if eq $d.Type "constructor" }}
			func Deploy{{$c.Name}}(sender seth.Sender, value *big.Int, {{range $i, $input := $d.Inputs}}{{if gt $i 0}}, {{end}}{{ArgName $input.Name}} {{ArgType $input.Type}}{{end}}) (*{{$c.Name}}, *seth.Receipt, error) {
				if value == nil {
					value = big.NewInt(0)
				}
				v := seth.Int(*value)
				receipt, err := sender.Create({{$c.Name}}Code, &v, "{{$d.Signature}}"{{range $i, $input := $d.Inputs}}, {{ArgName $input.Name}}{{end}})
				if err != nil {
					return nil, nil, err
				}
				return New{{$c.Name}}(receipt.Address, sender), receipt, nil
			}
		{{end}}
		
		{{if eq $d.Type "function" }}

			{{if $d.Constant}}

				// {{FuncName $d.Name}} calls the solidity view {{$c.Name}}.{{$d.Signature}}
				func (c *{{$c.Name}}) {{FuncName $d.Name}}({{range $i, $input := $d.Inputs}}{{if gt $i 0}}, {{end}}{{ArgName $input.Name}} {{ArgType $input.Type}}{{end}}) ({{range $i, $output := $d.Outputs}}{{ArgName $output.Name}} {{RetType $output.Type}}, {{end}}err error) {
					d := seth.NewABIDecoder({{range $i, $output := $d.Outputs}}{{if gt $i 0}}, {{end}}&{{ArgName $output.Name}}{{end}})
					err = c.s.ConstCall(c.addr, "{{$d.Signature}}", d{{range $i, $input := $d.Inputs}}, {{ArgName $input.Name}}{{end}})
					return
				}
			
			{{else}}

				// {{FuncName $d.Name}} calls the solidity function {{$c.Name}}.{{$d.Signature}}
				func (c *{{$c.Name}}) {{FuncName $d.Name}}({{range $i, $input := $d.Inputs}}{{if gt $i 0}}, {{end}}{{ArgName $input.Name}} {{ArgType $input.Type}}{{end}}) (res seth.Hash, err error) {
					return c.s.Send(c.addr, "{{$d.Signature}}"{{range $i, $input := $d.Inputs}}, {{ArgName $input.Name}}{{end}})
				}

			{{end}}

		{{end}}

		{{if eq $d.Type "event"}}
			
			type {{$c.Name}}{{FuncName $d.Name}} struct {
				Log *seth.Log{{range $i, $input := $d.Inputs}}
					{{ArgNameUpper $input.Name}} {{RetType $input.Type}}{{end}}
			}


			var {{$c.Name}}{{FuncName $d.Name}}Topic = seth.HashString("{{$d.Signature}}")


			func (e *{{$c.Name}}{{FuncName $d.Name}}) FromLog(log *seth.Log) error {
				if log.Topics[0].String() != {{$c.Name}}{{FuncName $d.Name}}Topic.String() {
					return fmt.Errorf("failed to decode {{$c.Name}}{{FuncName $d.Name}}. incorrect topic expected: %s actual: %s", {{$c.Name}}{{FuncName $d.Name}}Topic.String(), log.Topics[0].String())
				}

				{{range $i, $input := $d.Inputs}}
					{{if $input.Indexed}}
						if err := seth.DecodeABI(log.Topics[{{ inc $i }}], &e.{{ArgNameUpper $input.Name}}); err != nil {
							return fmt.Errorf("failed to decode {{$c.Name}}{{FuncName $d.Name}} event property {{ArgNameUpper $input.Name}}: %s", err)
						}
					{{end}}
				{{end}}

				return seth.DecodeABI(log.Data{{range $i, $input := $d.Inputs}}{{if not $input.Indexed}}, &e.{{ArgNameUpper $input.Name}}{{end}}{{end}})
			}

			type {{$c.Name}}{{FuncName $d.Name}}Iterator struct {
				Event *{{$c.Name}}{{FuncName $d.Name}}
				Error error
				Close func()

				errors chan error
				events chan *{{$c.Name}}{{FuncName $d.Name}}
			}

			func (i *{{$c.Name}}{{FuncName $d.Name}}Iterator) Next() bool {

				select {
					case i.Error = <-i.errors:
						return false
					case i.Event = <-i.events:
						return i.Event != nil
				}

			}

			func (c *{{$c.Name}}) Filter{{FuncName $d.Name}}(ctx context.Context, start, end int64) (*{{$c.Name}}{{FuncName $d.Name}}Iterator, error) {
				
				filter, err := c.s.FilterTopics([]*seth.Hash{&{{$c.Name}}{{FuncName $d.Name}}Topic}, c.addr, start, end)
				if err != nil {
					return nil, err
				}

				i := &{{$c.Name}}{{FuncName $d.Name}}Iterator{
					errors: make(chan error, 1),
					events: make(chan *{{$c.Name}}{{FuncName $d.Name}}),
					Close: filter.Close,
				}

				go func() {
					defer filter.Close()
					for {
						if filter.Err() != nil {
							i.errors <- err
							return
						}
						select {
						case <-ctx.Done():
							i.errors <- ctx.Err()
							return
						case msg := <-filter.Out():
							if msg == nil {
								i.events <- nil
								return
							}

							x := &{{$c.Name}}{{FuncName $d.Name}}{
								Log: msg,
							}
							if err := x.FromLog(msg); err != nil {
								i.errors <- err
								return
							}
							i.events <- x
						}
					}
				}()

				return i, nil
			}
		{{end}}

	{{end}}

{{end}}


{{range $c := .contracts}}

	var {{$c.Name}}Code = {{CodeVar $c.Code}}

{{end}}`
